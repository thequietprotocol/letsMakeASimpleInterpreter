Goal: To interpret the following Pascal code

program factorial;

function factorial(n: integer): longint;
begin
    if n = 0 then
        factorial := 1
    else
        factorial := n * factorial(n - 1);
end;

var
    n: integer;

begin
    for n := 0 to 16 do
        writeln(n, '! = ', factorial(n));
end.


*   A grammar specifies the syntax of a programming language in a concise manner. Unlike syntax diagrams, grammars are very compact.
*   There is a set of tools, called parser generators, which accept a grammar as an input and automatically generate a parser.
*   A grammar consists of a sequence of rules, also known as productions.
*   A rule consists of a non-terminal, called the head or left-hand side of the production, a colon, and a sequence of terminals 
    and/or non-terminals, called the body or right-hand side of the production.
*   The non-terminal symbol on the left side of the first rule is called the start symbol.

|      - Alternatives. A bar means “or”. So (MUL | DIV) means either MUL or DIV.
( … )  - An open and closing parentheses mean grouping of terminals and/or non-terminals as in (MUL | DIV).
( … )* - Match contents within the group zero or more times.

* A grammar defines a language by explaining what sentences it can form.

Here are the guidelines that we will use to convert the grammar to source code:

1.  Each rule, R, defined in the grammar, becomes a method with the same name, and references to that rule become a method call: R(). 
    The body of the method follows the flow of the body of the rule using the very same guidelines.

2. Alternatives (a1 | a2 | aN) become an if-elif-else statement

3. An optional grouping (…)* becomes a while statement that can loop over zero or more times

4.  Each token reference T becomes a call to the method eat: eat(T). The way the eat method works is that it consumes the token T if it 
    matches the current lookahead token, then it gets a new token from the lexer and assigns that token to the current_token internal variable.


The interpreter that would evaluate an expression as soon as the parser recognized a certain language construct like addition, subtraction, 
multiplication, or division is called syntax-directed interpreter. It usually makes a single pass over the input 
and is suitable for basic language applications. In order to analyze more complex Pascal programming language constructs, 
we need to build an intermediate representation (IR).

One IR: Abstract Syntax Tree

A parse-tree (sometimes called a concrete syntax tree) is a tree that represents the syntactic structure of a language construct according to 
our grammar definition. It basically shows how your parser recognized the language construct or, in other words, it shows how the start symbol 
of your grammar derives a certain string in the programming language.

An abstract syntax tree (AST) is a tree that represents the abstract syntactic structure of a language construct where each interior node and 
the root node represents an operator, and the children of the node represent the operands of that operator.

Here are the main differences between ASTs and Parse trees:

- ASTs uses operators/operations as root and interior nodes and it uses operands as their children.
- ASTs do not use interior nodes to represent a grammar rule, unlike the parse tree does.
- ASTs don’t represent every detail from the real syntax (that’s why they’re called abstract) - no rule nodes and no parentheses, for example.
- ASTs are dense compared to a parse tree for the same language construct.

